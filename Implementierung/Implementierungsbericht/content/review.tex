\section{Review}
\subsection{Einhaltung des Implementierungsplans}
Die Aufteilung des Teams in ein Server- und ein Client-Entwicklungsteam wurde beibehalten und erwies sich als sehr hilfreich, da sich jedes Teammitglied auf ein Teilgebiet konzentrieren konnte.
\subsubsection{Server}
Die Einrichtung der Entwicklungsumgebung lief ohne Probleme. Die Umsetzung vom Datenbankzugriff brauchte zunächst ein paar Tage mehr Zeit als veranlagt, was allerdings nicht zu Problemen führte, da die Schnittstellen klar definiert waren. Auch bei der Entwicklung der REST-Schnittstellen kam es zu minimalen Verzögerungen.\\
 Mit der Implementierung der Filterarchitektur wurde bereits früher begonnen, sodass diese von der Datenbankzugriffsschicht verwendet werden konnte, allerdings wurde eine Änderung der Condition-Struktur nötig, wie in Kapitel~\ref{subsubsec:filter} beschrieben, weshalb der Zugriff auf Module über Filter erster später möglich war.\\
 Die Implementierungsreihenfolge der weiteren Komponenten wurde vertauscht. So wurden zunächst Report-Generierung und der Authorization"=Endpoint implementiert, was beides zusammen innerhalb von zwei Tagen erledigt wurde. Erst daraufhin wurde mit der Implementierung der Verifizierung begonnen, was ebenfalls nur zwei Tage benötigte. \\
 Die Generierung hingegen wurde fortlaufend über die ganze Dauer der Implementierungsphase entwickelt. \\
 Die letzten vier Tage wurden für erste Integrationstests von Server und Client genutzt, um den Mehraufwand in der Qualitätssicherungsphase gering zu halten. Hierbei wurden ein paar Probleme in Bezug auf das Zusammenspiel von Datenbank- und REST-Schnittstelle sichtbar, welche es zu beheben galt. Näheres hierzu findet sich in Kapitel~\ref{subsec:problems}.
 \include{diagrams/server_gantt}
 
 \subsubsection{Client}
 Aufgrund der heterogenen Struktur von Entwicklungsumgebungen im Javascript-Umfeld erwies sich zunächst die Einrichtung der Test- und Entwicklungsumgebung als eine größere Herausforderung als zunächst angenommen. Dies verzögerte den Entwicklungsprozess um zwei Tage. 
 Aufgrund der steilen Lernkurve beim Erlernen von JavaScript verzögerte sich dann auch die erste Phase, in welcher die Modell-Klassen implementiert wurden um ca. vier bis fünf Tage. Es erwies sich hierbei als hilfreich, für den Client bereits zu diesem Zeitpunkt Integrationstests mit einem REST"=Webservice"=Mock zu schreiben, um so sicherstellen zu können, dass die Modell-Klassen der Spezifikation entsprechen. Dies führte zu einer deutlich höheren Stabilität des Modells, beanspruchte allerdings gleichzeitig zwei weitere Tage.\\
 Da jedoch die Views trotz vorhandener Schnittstellen nicht ohne funktionierende Modell-Klassen getestet werden konnten, konnte mit diesen  insgesamt erst ca. sieben Tage später begonnen werden. Dank der guten Einarbeitung während der Modell-Implementierung war es jedoch trotzdem möglich, den Zeitplan einzuhalten und die View rechtzeitig fertigzustellen. Bei der Implementierung der View zeigte sich, dass es sinnvoller ist, nach der \enquote{Top"=Down}"=Methode zu entwickeln und die Implementierung mit dem MainRouter sowie den Subviews zu beginnen. Durch diese Veränderung im Implementierungsplan ließen sich die View-Komponenten von Anfang an exzellent testen.\\
 Insgesamt wurde das Projekt rechtzeitig und erfolgreich fertiggestellt -- nicht zuletzt durch den Test der Kommunikation zwischen Client und Server, welcher in den letzten vier Tagen der Implementierungsphase durchgeführt wurde, um eine grundlegende Stabilität des Systems zu sichern.
 \include{diagrams/client_gantt}
 
 
 \subsection{Unerwartete Probleme}
 \label{subsec:problems}
 Selbstverständlich funktioniert bei der Implementierung eines Softwareprodukts nicht immer alles problemlos. Im Folgenden sind die Hürden dargestellt, die sich uns im Laufe der Implementierung stellten.
 
 Zunächst ist anzumerken, dass keine Probleme durch Entwurfsbestandteile, welche sich als unpraktikabel erwiesen, aufgetreten sind. Der Entwurf musste nur minimal überarbeitet werden. \\
 Die Client-Entwicklung wurde anfangs durch die steile Lernkurve beim Erlernen von JavaScript ausgebremst, da der Großteil des Teams bislang nur mit Java gearbeitet hatte -- was sich aber nach dem Überwinden der ersten Hürden schnell löste. Auch stellte die Einrichtung der Client-Entwicklungsumgebung eine kleine Hürde dar.\\
 Ein größeres Problem bestand im Zusammenspiel von REST- und Datenbankschnittstelle: Da das von uns verwendete Object-Relational-Mapping-Tool \textit{Hibernate} sehr stark sogenanntes \enquote{Lazy Loading}\footnote{Das heißt, zu einem geladenen Objekt assoziierte Datenbankeinträge aus anderen Tabellen werden erst beim Zugriff auf die entsprechenden Getter nachgeladen} einsetzt, ist nach dem Schließen der Datenbankverbindung ein Nachladen von assoziierten Relationen von aus der Datenbank geladenen Instanzen nicht mehr möglich. So erschien es zunächst nötig, die Datenbankverbindung erst nach dem Antworten auf die Clientanfrage zu schließen. Die JAX-RS-Implementierung \textit{Jersey} konstruiert Antworten auf Anfragen jedoch erst, nachdem alle Trigger, die nach dem Zusammenbauen der Antwort diese manipulieren können, aufgerufen wurden, weshalb es nicht einfach möglich war, mit einem solchen Trigger die Datenbankverbindung zu schließen. Da es jedoch keinen späteren Zeitpunkt gibt, zu dem das Schließen der Verbindung veranlasst werden kann, mussten sogenannte \textit{Data-Transfer-Objects} (DTOs) hinzugefügt werden, die bereits vor dem Schließen der Datenbankverbindung alle Antwortdaten laden und zwischenspeichern, um dann serialisiert werden zu können.
 Dies konnte das Problem vollständig lösen. \\
 Hinzu kam weiterhin, dass am Wochenende vor unserem Abgabetermin die komplette Internetanbindung des Wohnheims, in welchem vier der sechs Teammitglieder wohnen, ausfiel, was die Verwendung von Versionsverwaltung und Recherchen erheblich erschwerte. \\
 
 \subsection{Resümee}
 Abschließend kommen wir zu der Erkenntnis, dass wir direkt zu Beginn die Schnittstellen zwischen Client und Server hätten mocken sollen. Viele Probleme sind uns erst bei der Integration aufgefallen. Zudem hätten wir mehr kommunizieren müssen: Denn dadurch, dass zunächst jeder für sich selbst entwickelt hat, sind manche Probleme erst zuletzt aufgefallen. Durch bessere Kommunikation hätte man auch interne Fristen besser einhalten können.
 
 Als sinnvoll erwiesen hat sich die Trennung von Client- und Server"=Entwicklungsteam, da so eine klare Aufgabenverteilung im Team bestand. Außerdem hat jeder von uns sehr viele neue praktische Erkenntnisse im Bereich der Web"=App"=Implementierung gewonnen.
 
 